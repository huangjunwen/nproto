// Code generated by protoc-gen-nproto2. DO NOT EDIT.

package sendmail

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	msg "github.com/huangjunwen/nproto/v2/msg"
	rpc "github.com/huangjunwen/nproto/v2/rpc"
	reflect "reflect"
)

// --- RPC stub for SendMailSvc ---

// @@nprpc@@
type SendMailSvc interface {
	Send(context.Context, *Email) (*EmailEntry, error)

	List(context.Context, *empty.Empty) (*EmailEntries, error)
}

// SendMailSvcSpec contains method specs of service SendMailSvc.
type SendMailSvcSpec struct {
	specSend rpc.RPCSpec
	specList rpc.RPCSpec
}

type clientSendMailSvc struct {
	handlerSend rpc.RPCHandler
	handlerList rpc.RPCHandler
}

// NewSendMailSvcSpec creates a new SendMailSvcSpec.
func NewSendMailSvcSpec(svcName string) *SendMailSvcSpec {
	return &SendMailSvcSpec{
		specSend: rpc.MustRPCSpec(
			svcName,
			"Send",
			func() interface{} { return new(Email) },
			func() interface{} { return new(EmailEntry) },
		),
		specList: rpc.MustRPCSpec(
			svcName,
			"List",
			func() interface{} { return new(empty.Empty) },
			func() interface{} { return new(EmailEntries) },
		),
	}
}

// SpecMap returns a mapping from method name to method spec.
func (spec *SendMailSvcSpec) SpecMap() map[string]rpc.RPCSpec {
	return map[string]rpc.RPCSpec{
		"Send": spec.specSend,
		"List": spec.specList,
	}
}

// ServeSendMailSvc serves SendMailSvc service using a RPCServer.
func ServeSendMailSvc(server rpc.RPCServer, svcSpec *SendMailSvcSpec, svc SendMailSvc) (err error) {
	if err = server.RegistHandler(
		svcSpec.specSend,
		func(ctx context.Context, input interface{}) (interface{}, error) {
			return svc.Send(ctx, input.(*Email))
		},
	); err != nil {
		return err
	}
	defer func() {
		if err != nil {
			// Deregist if error.
			server.RegistHandler(svcSpec.specSend, nil)
		}
	}()

	if err = server.RegistHandler(
		svcSpec.specList,
		func(ctx context.Context, input interface{}) (interface{}, error) {
			return svc.List(ctx, input.(*empty.Empty))
		},
	); err != nil {
		return err
	}
	defer func() {
		if err != nil {
			// Deregist if error.
			server.RegistHandler(svcSpec.specList, nil)
		}
	}()

	return nil
}

// InvokeSendMailSvc invokes SendMailSvc service using a RPCClient.
func InvokeSendMailSvc(client rpc.RPCClient, svcSpec *SendMailSvcSpec) SendMailSvc {
	return &clientSendMailSvc{
		handlerSend: client.MakeHandler(svcSpec.specSend),
		handlerList: client.MakeHandler(svcSpec.specList),
	}
}
func (svc *clientSendMailSvc) Send(ctx context.Context, input *Email) (*EmailEntry, error) {
	output, err := svc.handlerSend(ctx, input)
	if err != nil {
		return nil, err
	}
	return output.(*EmailEntry), nil
}

func (svc *clientSendMailSvc) List(ctx context.Context, input *empty.Empty) (*EmailEntries, error) {
	output, err := svc.handlerList(ctx, input)
	if err != nil {
		return nil, err
	}
	return output.(*EmailEntries), nil
}

// --- Msg stub for EmailEntry ---

// EmailEntrySpec implements msg.MsgSpec interface.
type EmailEntrySpec string

// SubjectName returns string(spec).
func (spec EmailEntrySpec) SubjectName() string {
	return string(spec)
}

// NewMsg returns new(EmailEntry).
func (spec EmailEntrySpec) NewMsg() interface{} {
	return new(EmailEntry)
}

var (
	msgType_EmailEntry = reflect.TypeOf((*EmailEntry)(nil))
)

// MsgType returns reflect.TypeOf((*EmailEntry)(nil)).
func (spec EmailEntrySpec) MsgType() reflect.Type {
	return msgType_EmailEntry
}

var (
	msgValue_EmailEntry = &EmailEntry{}
)

// MsgValue returns a sample *EmailEntry.
func (spec EmailEntrySpec) MsgValue() interface{} {
	return msgValue_EmailEntry
}

// SubscribeEmailEntry subscribes to a EmailEntry topic.
func SubscribeEmailEntry(
	subscriber msg.MsgSubscriber,
	spec EmailEntrySpec,
	queue string,
	handler func(context.Context, *EmailEntry) error,
	opts ...interface{}) error {

	return subscriber.Subscribe(spec, queue, func(ctx context.Context, msg interface{}) error {
		return handler(ctx, msg.(*EmailEntry))
	}, opts...)
}

// PublishEmailEntry publish a EmailEntry message.
func PublishEmailEntry(
	publisher msg.MsgPublisher,
	ctx context.Context,
	spec EmailEntrySpec,
	msg *EmailEntry,
) error {
	return publisher.Publish(ctx, spec, msg)
}
